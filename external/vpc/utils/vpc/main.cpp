// Copyright Valve Corporation, All rights reserved.
//
// Purpose: VPC

#include <string>

#include "vpc.h"
#include "dependencies.h"

#include "tier0/logging.h"

#ifdef _WIN64
#include "memory_reservation_x64.h"
#endif

#include "tier0/memdbgon.h"

DEFINE_LOGGING_CHANNEL_NO_TAGS(LOG_VPC, "VPC");

namespace {

/**
 * @brief Is two phase VPC required.
 * @param argc Argc.
 * @param argv Argv.
 * @return true if two phase, false if not.
 */
bool IsTwoPhaseVpc(int argc, char **argv) noexcept {
  for (int i{0}; i < argc; i++) {
    if (V_stricmp("/windows", argv[i]) == 0) {
      return true;
    }
  }

  return false;
}

}  // namespace

// main
// VPC is a DLL in Source.
#if defined(STANDALONE_VPC) || defined(OSX) || defined(LINUX)
/**
 * @brief Main entry point.
 */
int main(int argc, char **argv)
#else
/**
 * @brief Main entry point for DLL.
 * @param argc Argument count.
 * @param argv Arguments.
 * @return return code.
 */
int vpcmain(int argc, char **argv)
#endif
{
#ifdef _WIN64
  // Catch x64 errors early.
  vpc::win::ReserveBottomMemoryFor64Bit();
#endif

  const bool is_windows_two_phase{IsTwoPhaseVpc(argc, argv)};

  g_pVPC = new CVPC();

  if (is_windows_two_phase) {
    // We're going to do some grotesque hackery by manipulating the command line
    // arguments.
    //
    // First we're going to generate a VPC object to generate all the 32-bit
    // .vcxproj files but not write a solution file.  Then we'll run it for the
    // 64-bit .vcxproj files, then write a solution file containing both (if a
    // solution file was requested).
    //
    // To accomplish this, subtract the /windows parameter (and /MKSLN if
    // present), run, extract the list of generated project files, add a /WIN64
    // (and put /MKSLN back if necessary) and pass in the generated project file
    // list.
    bool should_build_solution{false};
    char solution_path[_MAX_PATH];

    const char *new_argv[128] = {nullptr};
    unsigned new_argc{0};

    // Do the 32-bit VPC, capturing the list of project files produced.
    Assert(static_cast<unsigned>(argc) <= std::size(new_argv));
    for (int i{0}; i < argc; i++) {
      const char *arg{argv[i]};

      if (!V_stricmp(arg, "/windows") || !V_stricmp(arg, "/dp")) {
        // Skip
      } else if (!V_stricmp(arg, "/mksln") && i + 1 < argc) {
        // If the next parameter is a standard + or - or / or * parameter, then
        // we take that to be the name of the solution file. So vpc /mksln
        // +engine would generate engine.sln.
        const char *next_arg{argv[i + 1]}, sign{next_arg[0]};

        if (sign == '+' || sign == '-' || sign == '/' || sign == '*' ||
            sign == '@') {
          V_strncpy(solution_path, &next_arg[1], static_cast<intp>(std::size(solution_path)));
        } else {
          V_strncpy(solution_path, next_arg, static_cast<intp>(std::size(solution_path)));
          i++;
        }

        should_build_solution = true;
      } else {
        new_argv[new_argc++] = arg;
      }
    }

    if (new_argc >= std::size(new_argv)) {
      Error("Overflow argc. Max %zu, got %u.", std::size(new_argv),
            new_argc + 1);
    }

    // Add a /dp parameter to decorate the 32-bit project names with (win32).
    // This makes it easier to differentiate between projects in the solution
    // explorer.
    new_argv[new_argc++] = "/dp";

    if (new_argc >= std::size(new_argv)) {
      Error("Overflow argc. Max %zu, got %u.", std::size(new_argv),
            new_argc + 1);
    }

    // Add a define for PHASE1 for any VPC files that need to be aware of that
    // sort of thing.
    new_argv[new_argc++] = "/define:PHASE1";

    if (!g_pVPC->Init(new_argc, new_argv)) return 1;

    const int rc{g_pVPC->ProcessCommandLine()};
    if (rc != 0) return rc;

    // Grab a list of all the project files that got generated by this pass, we
    // will stuff these into the solution file later.  If we aren't building a
    // solution, then don't bother.
    CUtlVector<CDependency_Project *> dependencies;
    if (should_build_solution) {
      g_pVPC->GetProjectDependencies(dependencies);
    }

    // Now reconstruct the command line with the 64-bit flag and the solution
    // file added back in.  Decrement cParms to eat the /dp and /define we added
    // before.
    new_argc -= 2;
    new_argv[new_argc++] = "/win64";

    // Add a define for PHASE2 for any VPC files that need to be aware of that
    // sort of thing.  Example: Projects that generate headers-only and are not
    // bitness specific.
    new_argv[new_argc++] = "/define:PHASE2";

    if (should_build_solution) {
      if (new_argc >= std::size(new_argv)) {
        Error("Overflow argc. Max %zu, got %u.", std::size(new_argv),
              new_argc + 1);
      }

      new_argv[new_argc++] = "/mksln";

      if (new_argc >= std::size(new_argv)) {
        Error("Overflow argc. Max %zu, got %u.", std::size(new_argv),
              new_argc + 1);
      }

      new_argv[new_argc++] = solution_path;
    }

    g_pVPC->Shutdown();
    delete g_pVPC;
    g_pVPC = new CVPC();

    if (!g_pVPC->Init(new_argc, new_argv)) return 1;

    if (should_build_solution) {
      g_pVPC->SetPhase1Projects(&dependencies);
    }
  } else {
    if (!g_pVPC->Init(argc, const_cast<const char **>(argv))) return 0;
  }

  const int rc{g_pVPC->ProcessCommandLine()};

  g_pVPC->Shutdown();
  delete g_pVPC;
  g_pVPC = nullptr;

  return rc;
}

// VPC is a DLL in Source.
#if !(defined(STANDALONE_VPC) || defined(OSX) || defined(LINUX))
#include "ilaunchabledll.h"
#include "tier1/interface.h"

// VPC is launched by vpc.exe, which is a copy of binlaunch.exe.  All binlaunch
// does is setup the path to game\bin and load an ILaunchableDLL interface out
// of a DLL with the same name as the exe.
class VpcLaunchableDLL : public ILaunchableDLL {
 public:
  // All vpc.exe does is load the vpc DLL and run this.
  virtual int main(int argc, char **argv) { return vpcmain(argc, argv); }
};

EXPOSE_SINGLE_INTERFACE(VpcLaunchableDLL, ILaunchableDLL,
                        LAUNCHABLE_DLL_INTERFACE_VERSION);
#endif
